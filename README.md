# SecuritySample
Hiding encrypted secret API keys in C/C++ code and decrypting them with Java code.

Using SafetyNet Attestation API.

# Introduction

## Part1. Get encrypted data from native code through NDK

- Hiding Secret keys in C/C++ code.
- Using [RSAHelper] to encrypt your secret keys, you post those encrypted strings to this project. Then, fill in the parameters generated by [RSAHelper] in this project for decryption to decrypt the messages.

## Part2. Assess the security and compatibility of the Android environments in which your apps run
- Call SafetyNet Attestation API.

# Instruction Part1

## Step1. Generate a pair of RSA keys and encrypt your message.
Running [RSAHelper] to get encrypted messages, a pair of RSA modulus and exponent for decryption.

## Step2. Fill in MODULUS and EXPONENT
In [JNIHelper]

```Java
private final static String MODULUS = "Fill in the modulus created by RSAHelper";
private final static String EXPONENT = "Fill in the exponent created by RSAHelper";
```

## Step3. Add the decryption method to your project
```Java
public static String decryptRSA(String message) throws NoSuchAlgorithmException, NoSuchPaddingException,
        InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException,
        InvalidAlgorithmParameterException, ClassNotFoundException, InvalidKeySpecException {
    Cipher c2 = Cipher.getInstance(Algorithm.rules.get("RSA")); // 创建一个Cipher对象，注意这里用的算法需要和Key的算法匹配

    BigInteger m = new BigInteger(Base64.decode(MODULUS.getBytes(), Base64.DEFAULT));
    BigInteger e = new BigInteger(Base64.decode(EXPONENT.getBytes(), Base64.DEFAULT));
    c2.init(Cipher.DECRYPT_MODE, convertStringToPublicKey(m, e)); // 设置Cipher为解密工作模式，需要把Key传进去
    byte[] decryptedData = c2.doFinal(Base64.decode(message.getBytes(), Base64.DEFAULT));
    return new String(decryptedData, Algorithm.CHARSET);
}

public static Key convertStringToPublicKey(BigInteger modulus, BigInteger exponent)
        throws ClassNotFoundException, NoSuchAlgorithmException, InvalidKeySpecException {
    byte[] modulusByteArry = modulus.toByteArray();
    byte[] exponentByteArry = exponent.toByteArray();

    // 由接收到的参数构造RSAPublicKeySpec对象
    RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(new BigInteger(modulusByteArry),
            new BigInteger(exponentByteArry));
    // 根据RSAPublicKeySpec对象获取公钥对象
    KeyFactory kFactory = KeyFactory.getInstance(Algorithm.KEYPAIR_ALGORITHM);
    PublicKey publicKey = kFactory.generatePublic(rsaPublicKeySpec);
    // System.out.println("==>public key: " +
    // bytesToHexString(publicKey.getEncoded()));
    return publicKey;
}
```

## Step4. Create C/C++ files
- There are two ways to use JNI -- CmakeLists.txt and Android.mk, I used Android.mk here.
- Create jni folder in main/ .Then add [Android.mk], [Application.mk] and C/C++ files([Config.cpp]).

![JNI 1][NDK1]

- In build.gradle:

```gradle
externalNativeBuild {
    ndkBuild {
        path 'src/main/jni/Android.mk'
    }
}
```

- In MainActivity

```Java
static {
    //relate to LOCAL_MODULE in Android.mk
    System.loadLibrary("keys");
}
/**
 * A native method that is implemented by the 'native-lib' native library,
 * which is packaged with this application.
 */
public native String[] getAuthChain(String key);
```

## Step4. Run your app

```Java
    private final static String TAG = "MainActivity";

@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        StringBuilder sb = new StringBuilder();
    try {
        // Example of a call to a native method
        TextView tv = (TextView) findViewById(R.id.sample_text);

        String[] authChain = getAuthChain("LOGIN");
        sb.append("Decrypted secret keys\n[ ");
        for (int i = 0; i < authChain.length; i++) {
            sb.append(decryptRSA(authChain[i]));
            sb.append(" ");
        }
        sb.append("]\n");

        String[] authChain2 = getAuthChain("OTHER");
        sb.append("secret keys\n[ ");
        for (int i = 0; i < authChain.length; i++) {
            sb.append(authChain2[i]);
            sb.append(" ");
        }
        sb.append("]");
        Log.d(TAG, sb.toString());
        tv.setText(sb.toString());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

# Instruction Part2
**Two things you must know before you start developing.**
1. DO NOT add any safetyNet meta-data in your manifest
2. Use SafetyNetApi the deprecated class or you'd probably get 403 error by calling SafetyNet.getClient(context)

- I copied code from [safetynethelper] to [SafetyNet].

## Step1. Get API keys from google develop console
- General API key here: https://console.developers.google.com/, and don't forget to add and enable "Android Device Verification API"

- In gradle.porpeties, add your google API key
```
safetynet_api_key = XXXXXXXXX
```

- In build.gradle
```gradle
android {
  defaultConfig {
          buildConfigField("String", "API_KEY", "\"${safetynet_api_key}\"")
      }
}

```

- Ignore manifest
```xml
<!--<meta-data-->
    <!--android:name="com.google.android.safetynet.ATTEST_API_KEY"-->
    <!--android:value="${safetynet_api_key}" />-->
```

## Step2.
```java
SafetyNetHelper safetyNetHelper = new SafetyNetHelper(BuildConfig.API_KEY);

//In the case, you can let your server decide how to deal with false ctsProfileMatch situation.
safetyNetHelper.enableConnectToGoogleServer(false);
safetyNetHelper.requestTest(MainActivity.this, new SafetyNetHelper.SafetyNetWrapperCallback() {
    @Override
    public void error(int errorCode, String errorMessage) {
        Log.e(TAG, errorCode + ":" + errorMessage);
        Log.d(TAG, format(safetyNetHelper.getLastResponse()));
    }

    @Override
    public void success(boolean ctsProfileMatch, boolean basicIntegrity) {
        Log.d(TAG, "SafetyNet req success: ctsProfileMatch:" + ctsProfileMatch + " and basicIntegrity, " + basicIntegrity);
        Log.d(TAG, format(safetyNetHelper.getLastResponse()));
    }
});

private String format(SafetyNetResponse r) {
    StringBuilder sb = new StringBuilder();
    sb.append("[");
    for (String s : r.getApkCertificateDigestSha256()) {
        sb.append(s);
        sb.append(", ");
    }
    sb.delete(sb.length() - 2, sb.length());
    sb.append("]");
    SimpleDateFormat newFormat = new SimpleDateFormat("yyyy/MM/dd hh:mm:ss", Locale.TAIWAN);
    String formattedTime = newFormat.format(r.getTimestampMs());
    return String.format("Request Time:\n%s\n\nNonce:\n%s\n\nPackageName:\n%s\n\nApkCertificateDigestSha256:\n%s\n\nApkDigestSha256:\n%s\n\nctsProfileMatch:\n%s\n\nbasicIntegrity:\n%s", formattedTime, r.getNonce(), r.getApkPackageName(), sb.toString(), r.getApkDigestSha256(), r.isCtsProfileMatch(), r.isBasicIntegrity());
}
```

## Step3.
I run this app on a real device and the nox monitor, I got two different JWS responses.

- On my mobile phone, ctsProfileMatch and basicIntegrity were true.
```JSON
{"nonce":"XYFykVQX2mNyVDYZa4YAu8gBP6/3XWqg+zloYjhrg9M=",
"timestampMs":1498718050630,
"apkPackageName":"com.catherine.securitysample",
"apkDigestSha256":"dDUhx9ODbLHNYxN8Is+1RX/9RWhQ3FwCpRWLHFP5Qp8=",
"ctsProfileMatch":true,
"extension":"CXGWLc3ajPR5",
"apkCertificateDigestSha256":["9mLFS3eHWOBcHlA4MmODmfGvzgkbg2YSQ2z/ww9lCfw="],
"basicIntegrity":true}​
```

- On nox monitor, ctsProfileMatch and basicIntegrity were false.
```JSON
{"nonce":"3QVAX20nI/uir405vctoInSvgYYudRUFts7gLDDGCxE=​",
"timestampMs":1498718484795​,
"apkPackageName":"com.catherine.securitysample",
"apkDigestSha256":"dDUhx9ODbLHNYxN8Is+1RX/9RWhQ3FwCpRWLHFP5Qp8=",
"ctsProfileMatch":false,
"extension":"CXGWLc3ajPR5",
"apkCertificateDigestSha256":["9mLFS3eHWOBcHlA4MmODmfGvzgkbg2YSQ2z/ww9lCfw="],
"basicIntegrity":false}​​
```

If you want to read more about google security services for Android, you can watch [Google Security Services for Android : Mobile Protections at Google Scale], the youtube video. Or you could see my note [README_cn], they are almost the same.

# Warning
When you add new secret keys, you must refill modulus, exponent and the other encrypted keys, because you get different RSA KeyPair(private key and public key) every execution.

# License

```
Copyright 2017 Catherine Chen (https://github.com/Catherine22)

Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
```

[RSAHelper]:<https://github.com/Catherine22/RSAHelper>
[MainActivity]: <https://github.com/Catherine22/SecuritySample/blob/master/app/src/main/java/com/catherine/securitysample/MainActivity.java>
[JNIHelper]: <https://github.com/Catherine22/SecuritySample/blob/master/app/src/main/java/com/catherine/securitysample/JNIHelper.java>
[SafetyNet]: <https://github.com/Catherine22/SecuritySample/blob/master/app/src/main/java/com/catherine/securitysample/SafetyNet>
[Android.mk]:<https://github.com/Catherine22/SecuritySample/blob/master/app/src/main/jni/Android.mk>     
[Application.mk]:<https://github.com/Catherine22/SecuritySample/blob/master/app/src/main/jni/Application.mk>
[NDK1]: https://github.com/Catherine22/MobileManager/blob/master/jni1.png  
[safetynethelper]:<https://github.com/scottyab/safetynethelper>
[Google Security Services for Android : Mobile Protections at Google Scale]:<https://www.youtube.com/watch?v=exU1f_UBXGk>
[README_cn]:<https://github.com/Catherine22/SecuritySample/blob/master/README_cn.md>     
